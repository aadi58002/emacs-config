;;; Compiled snippets and support files for `rustic-mode'
;;; Snippet definitions:
;;;
(yas-define-snippets 'rustic-mode
		     '(("<in" "let ${1:problem} = sc.next::<${2:usize}>();\n$0" "Problem Input" t nil nil "/home/aditya-yadav/.config/emacs/snippets/rustic-mode/__input" nil nil)
		       ("<cp" "use std::io;\n#[allow(unused_imports)]\nuse std::io::Write;\n\n/**************************************************\n\nSTART OF TEMPLATE CODE\n\n *************************************************/\n#[allow(dead_code)]\nenum InputSource {\n    Stdin,\n    FromFile(Vec<String>),\n}\n\nstruct Scanner {\n    buffer: Vec<String>,\n    input_source: InputSource,\n}\n\n#[allow(dead_code)]\nfn next_permutation(nums: &mut Vec<usize>) -> bool {\n    if nums.len() < 2 {\n        return false;\n    }\n    let mut i = nums.len() - 1;\n    while i > 0 && nums[i - 1] >= nums[i] {\n        i -= 1;\n    }\n    if i == 0 {\n        return false;\n    }\n    let mut j = nums.len() - 1;\n    while j >= i && nums[j] <= nums[i - 1] {\n        j -= 1;\n    }\n    nums.swap(j, i - 1);\n    nums[i..].reverse();\n    true\n}\n\n\nimpl Scanner {\n    #[allow(dead_code)]\n    fn new() -> Self {\n        Self {\n            buffer: vec![],\n            input_source: InputSource::Stdin,\n        }\n    }\n    #[allow(dead_code)]\n    fn vec<T: std::str::FromStr>(&mut self, n: usize) -> Vec<T> {\n        (0..n).map(|_| self.next::<T>()).collect()\n    }\n\n    fn parse_next_line(&mut self) -> bool {\n        let mut input = String::new();\n        match &mut self.input_source {\n            InputSource::Stdin => {\n                if std::io::stdin().read_line(&mut input).expect(\"Failed read\") == 0 {\n                    return false;\n                }\n            }\n            InputSource::FromFile(lines) => match lines.pop() {\n                Some(line) => input = line,\n                None => return false,\n            },\n        }\n\n        self.buffer = input.split_whitespace().rev().map(String::from).collect();\n        return true;\n    }\n\n    fn next<T: std::str::FromStr>(&mut self) -> T {\n        loop {\n            if let Some(token) = self.buffer.pop() {\n                return token.parse().ok().expect(\"Failed parse\");\n            }\n\n            self.parse_next_line();\n        }\n    }\n\n    #[allow(dead_code)]\n    fn has_more_elements(&mut self) -> bool {\n        loop {\n            if !self.buffer.is_empty() {\n                return true;\n            }\n            if !self.parse_next_line() {\n                return false;\n            }\n        }\n    }\n\n    #[allow(dead_code)]\n    fn string(&mut self) -> String {\n        self.next::<String>()\n    }\n}\n\n/**************************************************\n\nEND OF TEMPLATE CODE\n\n *************************************************/\n\n\nfn main() {\n    let stdout = io::stdout();\n    #[allow(unused_variables, unused_mut)]\n    let mut out = std::io::BufWriter::new(stdout.lock());\n    let mut sc = Scanner::new();\n    let size = sc.next::<usize>();\n    $0\n}\n" "Competitive Programming with rust" t nil nil "/home/aditya-yadav/.config/emacs/snippets/rustic-mode/__CP" nil nil)))


;;; Do not edit! File generated at Sat Jan 28 16:42:52 2023
