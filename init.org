#+TITLE: Config of Emacs
#+DESCRIPTION: This is the org mode version of my config of emacs
#+FILETAGS: Config
#+PROPERTY: header-args :tangle ~/.config/emacs/init.el :lexical t

* Table of Content :toc:noexport:
- [[#early-initel][Early-init.el]]
- [[#customized-default][Customized Default]]
- [[#custom-function][Custom Function]]
- [[#package-initialize][Package initialize]]
  - [[#elpaca][Elpaca]]
  - [[#straight][Straight]]
- [[#packages][Packages]]
  - [[#keybindings][Keybindings]]
  - [[#generally-helpful-package][Generally helpful Package]]
  - [[#ui][UI]]
  - [[#coding][Coding]]
  - [[#completion][Completion]]
  - [[#org][Org]]
- [[#package-install-wait][Package install wait]]
- [[#keybindings-1][Keybindings]]
  - [[#leader-key-definer-definations][Leader key definer definations]]
  - [[#general-good-defaults][General good defaults]]
  - [[#custom-function-map][Custom Function Map]]
  - [[#org-agenda][Org agenda]]
  - [[#dashboard-map][Dashboard Map]]
  - [[#magit-map][Magit Map]]
  - [[#denote-map][Denote Map]]
  - [[#project][Project]]
  - [[#consult-map][Consult Map]]
  - [[#hop-map][Hop Map]]
  - [[#buffer-map][Buffer Map]]
  - [[#org-map][Org Map]]
  - [[#fold][Fold]]
  - [[#helpful][Helpful]]
  - [[#tempel][Tempel]]
  - [[#eglot][Eglot]]

* Early-init.el
Stopping Some modules which i don't use from being loaded like menu-bar-mode,tool-bar-mode,scroll-bar-mode and package.el (build in emacs package manager).
#+begin_src emacs-lisp :tangle ./early-init.el
;;; early-init.el --- Emacs early init -*- lexical-binding: t; -*-

;;; Commentary:

;; Emacs 27 introduced early-init.el, which is run before init.el, before
;; package and UI initialization happens.

;;; Code:
;; (setq init-file-debug t)
;; (setq messages-buffer-max-lines 100000)

;; If an `.el' file is newer than its corresponding `.elc', load the `.el'.
(setq load-prefer-newer t)

;; Set Garbage Collection threshold to 1GB during startup. `gcmh' will clean
;; things up later.
(setq gc-cons-threshold 1073741824
      gc-cons-percentage 0.6)

;; Write any customizations to a temp file so they are discarded.
(setq custom-file (make-temp-file "custom-" nil ".el"))

;; Faster to disable these here (before they've been initialized)
(menu-bar-mode -1)
(tool-bar-mode -1)
(scroll-bar-mode -1)
(setq scroll-conservatively 200
      scroll-margin 3)

;; Give the frame basic coloring while waiting for the theme to load. The main
;; purpose of this is to not blind me when it's dark by flashing a screen full
;; of white. These colors are from doom-one.
;; (set-face-attribute 'default nil :background "#282c34" :foreground "#bbc2cf")
;; Default frame settings. This is actually maximized, not full screen.
(push '(fullscreen . maximized) initial-frame-alist)
(push '(ns-transparent-titlebar . t) default-frame-alist)

;; Resizing the Emacs frame can be a terribly expensive part of changing the
;; font. By inhibiting this, we easily halve startup times with fonts that are
;; larger than the system default.
(setq frame-inhibit-implied-resize t
      frame-resize-pixelwise t)

(setq package-enable-at-startup nil)

(setq native-comp-async-report-warnings-errors nil)

(setq use-dialog-box t ; only for mouse events, which I seldom use
      use-file-dialog nil
      inhibit-splash-screen t
      inhibit-startup-screen t
      inhibit-startup-echo-area-message user-login-name ; read the docstring
      inhibit-startup-buffer-menu t)

;; Debugging
(setq debug-on-error t)

;; Reduce startup time due to file-handler matching
(defvar default-file-name-handler-alist file-name-handler-alist)
(setq file-name-handler-alist nil)

;; Set a few post-run handlers
(defun +gc-after-focus-change ()
  "Run GC when frame loses focus."
  (run-with-idle-timer
   5 nil
   (lambda () (unless (frame-focus-state) (garbage-collect)))))

(defun +reset-init-values ()
  (run-with-idle-timer
   1 nil
   (lambda ()
     (setq file-name-handler-alist default-file-name-handler-alist
           gc-cons-percentage 0.1
           gc-cons-threshold (* 100 1024 1024))
     (message "Set gc-cons-threshold = 100M & file-name-handler-alist restored")
     (when (boundp 'after-focus-change-function)
       (add-function :after after-focus-change-function #'+gc-after-focus-change)))))

(with-eval-after-load 'elpaca
  (add-hook 'elpaca-after-init-hook '+reset-init-values))

(provide 'early-init)
;;; early-init.el ends here
#+end_src
* Customized Default
Setting some default which suit well for me as well as enabling some performance optimizations
#+begin_src emacs-lisp
;;; init.el -*- lexical-binding: t; -*-
(defvar native-comp-deferred-compilation-deny-list nil)      ;;Native comp variable change in emacs 30
(setq create-lockfiles nil                                   ;;Don't want #..# files everywhere
      make-backup-files nil)                                 ;;Don't want Redundant copy of files
(setq recentf-max-menu-items 25)                             ;;Recent files opened list size
(setq revert-without-query '(".*"))                          ;;Keeps the file in sync with what is on the disk without a prompt to confirm
(recentf-mode 1)                                             ;;You can disable recent files here (just set 1 to -1)
(save-place-mode 1)                                          ;;When you open a file the cursor will be in the same position at which you closed the file
(setq read-process-output-max (* 1024 1024))                 ;;Emacs can read output from programs faster ( makes lsp mode faster )
(set-default-coding-systems 'utf-8)                          ;;Don't want to have encoding errors
(setq inhibit-startup-screen t)                              ;;Don't want to see the emacs startup screen
(setq visible-bell t)                                        ;;Blinks the top bar and modeline to the color set in doom-themes-visual-bell
(setq-default tab-width 4)                                   ;;The tab width battle continues
(setq-default evil-shift-width tab-width)                    ;;We want the tab width to be same in the vim mode of emacs
(setq-default indent-tabs-mode nil)                          ;;Don't want formatters to insert <TAB> just use spaces

(setq use-short-answers t)                                   ;; In prompt answer instead of typing complete yes with this y will work as well

(global-display-line-numbers-mode t)                         ;;All people like line numbers right
(setq display-line-numbers-type 'relative)

(setq custom-file (locate-user-emacs-file "custom.el"))
(load custom-file 'noerror 'nomessage)

(setq electric-pair-preserve-balance t)
(setq dired-recursive-copies 'always
      dired-recursive-deletes 'always)

(setq delete-by-moving-to-trash t
      dired-listing-switches "-AGFhlv --group-directories-first --time-style=long-iso"
      dired-dwim-target t
      dired-auto-revert-buffer #'dired-directory-changed-p
      dired-make-directory-clickable nil
      dired-free-space nil)

(setq resize-mini-windows t)

(add-hook 'dired-mode-hook #'hl-line-mode)
(setq dired-isearch-filenames 'dwim
      dired-create-destination-dirs 'ask
      dired-vc-rename-file t
      dired-do-revert-buffer (lambda (dir  (not (file-remote-p dir ))) )
      dired-clean-up-buffers-too t
      dired-clean-confirm-killing-deleted-buffers t
      dired-x-hands-off-my-keys t     ; easier to show the keys I use
      dired-bind-man nil
      dired-bind-info nil
      delete-by-moving-to-trash t
      +vertico-consult-fd-args "fd -p --color=never -i --type f -E node_modules --regex")

(put 'narrow-to-region 'disabled nil)

(electric-pair-mode 1)
(set-fringe-mode 10)
(setq auto-save-default t
      truncate-string-ellipsis "<>"
      which-key-idle-delay 0.5)
(setq x-stretch-cursor t
      window-combination-resize t
      global-auto-revert-mode 1
      global-auto-revert-non-file-buffers t)
(setq backup-directory-alist `((".*" . ,temporary-file-directory)))
(setq auto-save-file-name-transforms `((".*" ,temporary-file-directory t)))
#+end_src
* Custom Function
*** Org autoload
#+begin_src emacs-lisp
(autoload #'+org/dwim-at-point (concat user-emacs-directory "autoload/+org"))
#+end_src
*** Trailing whitespace
#+begin_src emacs-lisp
;; (setq-default show-trailing-whitespace t)
;; (add-hook 'prog-mode-hook
;;           (lambda () (font-lock-add-keywords nil '(("\\s-+$" 0 'trailing-whitespace)))))
#+end_src
*** Backspace
#+begin_src emacs-lisp
(defun my/backward-kill-word ()
  "Kill backward to the beginning of the current word, but do not cross lines."
  (interactive)
  (if (not (looking-back "^\\s-*")) (backward-kill-word 1) (delete-horizontal-space)))
#+end_src
*** File operations
[[https://github.com/doomemacs/doomemacs/blob/5c563d307b7fe0cc65e8d5c235565e96ccca3b35/lisp/lib/files.el#L464][Source: doomemacs/files.el at 5c563d307b7fe0cc65e8d5c235565e96ccca3b35 Â· doomemacs/do...]]
#+begin_src emacs-lisp
(defun adi--sudo-file-path (file)
  (let ((host (or (file-remote-p file 'host) "localhost")))
    (concat "/" (when (file-remote-p file)
                  (concat (file-remote-p file 'method) ":"
                          (if-let (user (file-remote-p file 'user))
                              (concat user "@" host)
                            host)
                          "|"))
            "sudo:root@" host
            ":" (or (file-remote-p file 'localname)
                    file))))

(defun adi/sudo-find-file (file)
  "Open FILE as root."
  (interactive "FOpen file as root: ")
  (find-file (adi--sudo-file-path file)))

(defun adi/sudo-this-file ()
  "Open the current file as root."
  (interactive)
  (find-file
   (adi--sudo-file-path
    (or buffer-file-name
        (when (or (derived-mode-p 'dired-mode)
                  (derived-mode-p 'wdired-mode))
          default-directory)))))

(defun adi/sudo-save-buffer ()
  "Save this file as root."
  (interactive)
  (let ((file (adi--sudo-file-path buffer-file-name)))
    (if-let (buffer (find-file-noselect file))
        (let ((origin (current-buffer)))
          (copy-to-buffer buffer (point-min) (point-max))
          (unwind-protect
              (with-current-buffer buffer
                (save-buffer))
            (unless (eq origin buffer)
              (kill-buffer buffer))
            (with-current-buffer origin
              (revert-buffer t t))))
      (user-error "Unable to open %S" file))))

#+end_src
*** Denote archive
#+begin_src emacs-lisp
(defun my-denote--add-todo-keyword ()
  "Add the todo keyword to the new captured note if it is under the Todo Sub directory"
  (let* ((file denote-last-path))
    (if (string= (file-name-directory file) (file-name-as-directory denote-todo-directory))
        (let* ((file-type (denote-filetype-heuristics file))
               (title (denote-retrieve-title-value file file-type))
               (keywords (denote-retrieve-keywords-value file file-type)))
          (denote-rename-file file title (append '("todo") keywords))))))

(defun my-denote--add-todo-or-archive-keyword (file file-type)
  "Replace todo with archive keyword (or vice versa) in FILE, given FILE-TYPE.
  See `my-denote-move-from-todo-to-archive'."
  (let* ((keywords (denote-retrieve-keywords-value file file-type)))
    (cond
     ((member "todo" keywords)
      (setq keywords (delete "todo" keywords)
            keywords (append '("archive") keywords)))
     ((member "archive" keywords)
      (setq keywords (delete "archive" keywords)
            keywords (append '("todo") keywords)))
     (t keywords))))

(defun my-denote-move-from-todo-to-archive ()
  (interactive)
  ;; Like the above example, but we pass values directly to
  ;; `denote-rename-file' instead of doing it interactively.  More
  ;; precisely, we re-use the existing title and keywords, while
  ;; adding "todo" to the list of keywords.
  (let* ((file (denote--rename-dired-file-or-prompt))
         (file-type (denote-filetype-heuristics file)))
    (denote-rename-file
     file
     (denote-retrieve-title-value file file-type)
     (my-denote--add-todo-or-archive-keyword file file-type)))
  (let* ((file (denote--rename-dired-file-or-prompt))
         (archive-target (string-replace "/Todo/" "/Archived/" file)))
    (rename-file file archive-target)
    (denote-update-dired-buffers)))
#+end_src
*** Random Element from the list
#+begin_src emacs-lisp
(defun random-element-of-list (items)
  ;; Selects a random element from a list
  (let* ((size (length items))
         (index (random size)))
    (nth index items)))
#+end_src
*** Competitive layout
With smart-compile this function is very useful to run multiple test cases with compilation.
#+begin_src emacs-lisp
(defun Competitive-coding-output-input-toggle ()
  ;; Open side buffer to show inputf.in and outputf.in files as input and output of code file with the `SPC m z` Keybinding in rust-mode
  (interactive)
  (delete-other-windows)
  (kill-matching-buffers "*.in")
  (evil-window-vsplit)
  (find-file (expand-file-name "inputf.in" default-directory))
  (evil-window-split)
  (find-file (expand-file-name "outputf.in" default-directory))
  (other-window 1)
  (enlarge-window-horizontally 40))
#+end_src
*** Rust reset
#+begin_src emacs-lisp
(defun rust-reset()
  ;;Delete the entire buffer and expand a default template defined in `./templates` with the `SPC m r` Keybinding in rust-mode
  (interactive)
  (widen)
  (erase-buffer)
  (tempel-insert 'chef)
  (narrow-to-defun))
#+end_src
*** Rust paste input
#+begin_src emacs-lisp
(defun code-input-refresh()
  ;; Places the clipboard content in the inputf.in file with the `SPC m i` Keybinding in rust-mode
  (interactive)
  (write-region (current-kill 0) nil (concat default-directory "inputf.in") nil)
  (Competitive-coding-output-input-toggle))
#+end_src
*** Copy current file
Rename the current file to the name given in clipboard and format it into a format like "game World" (in clipboard) to "Game-World.rs".
#+begin_src emacs-lisp
;; source: http://steve.yegge.googlepages.com/my-dot-emacs-file
(defun copy-current-file (new-name)
  "Copy current file to a NEW-NAME."
  (interactive (list
                (read-string "New name: " (current-kill 0) nil (current-kill 0))))
  (let ((name (buffer-name))
        (filename (buffer-file-name)))
    (if (not filename)
        (message "Buffer '%s' is not visiting a file!" name)
      (if (get-buffer new-name)
          (message "A buffer named '%s' already exists!" new-name)
        (copy-file filename (concat (replace-regexp-in-string " " "" (capitalize (replace-regexp-in-string "[^[:word:]_]" " " new-name))) ".rs") 1)))))
#+end_src
*** Kitty Async
Start a kitty terminal session where the emacs current file (works with open directory as well) is open.
#+begin_src emacs-lisp
(defun kitty-async-process ()
  "Launch a kitty terminal process in the current emacs directory"
  (interactive)
  (start-process "kitty" nil "setsid" "kitty" "-d" default-directory))
#+end_src
* Package initialize
** Elpaca
Elpaca package manager which support async install of packages for faster install.
It is in actively developing emacs package manager but it is not widely documented like straight.el or package.el by default.
#+begin_src emacs-lisp
(defvar elpaca-installer-version 0.3)
(defvar elpaca-directory (expand-file-name "elpaca/" user-emacs-directory))
(defvar elpaca-builds-directory (expand-file-name "builds/" elpaca-directory))
(defvar elpaca-repos-directory (expand-file-name "repos/" elpaca-directory))
(defvar elpaca-order '(elpaca :repo "https://github.com/progfolio/elpaca.git"
                              :ref nil
                              :files (:defaults (:exclude "extensions"))
                              :build (:not elpaca--activate-package)))
(when-let ((repo  (expand-file-name "elpaca/" elpaca-repos-directory))
           (build (expand-file-name "elpaca/" elpaca-builds-directory))
           (order (cdr elpaca-order))
           ((add-to-list 'load-path (if (file-exists-p build) build repo)))
           ((not (file-exists-p repo))))
  (condition-case-unless-debug err
      (if-let ((buffer (pop-to-buffer-same-window "*elpaca-installer*"))
               ((zerop (call-process "git" nil buffer t "clone"
                                     (plist-get order :repo) repo)))
               (default-directory repo)
               ((zerop (call-process "git" nil buffer t "checkout"
                                     (or (plist-get order :ref) "--"))))
               (emacs (concat invocation-directory invocation-name))
               ((zerop (call-process emacs nil buffer nil "-Q" "-L" "." "--batch"
                                     "--eval" "(byte-recompile-directory \".\" 0 'force)"))))
          (progn (require 'elpaca)
                 (elpaca-generate-autoloads "elpaca" repo)
                 (kill-buffer buffer))
        (error "%s" (with-current-buffer buffer (buffer-string))))
    ((error) (warn "%s" err) (delete-directory repo 'recursive))))
(require 'elpaca-autoloads)
(add-hook 'after-init-hook #'elpaca-process-queues)
(elpaca `(,@elpaca-order))

;; Install use-package support
(elpaca elpaca-use-package
  ;; Enable :elpaca use-package keyword.
  (elpaca-use-package-mode)
  ;; Assume :elpaca t unless otherwise specified.
  (setq elpaca-use-package-by-default t))

(if (fboundp 'elpaca-wait)(elpaca-wait))
#+end_src
** Straight
Straight.el if elpaca is too buggy for you. ( just replace all the :elpaca in package definations with :straight )
#+begin_src emacs-lisp
;; (defvar bootstrap-version)
;; (let ((bootstrap-file
;;          (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
;;         (bootstrap-version 6))
;;     (unless (file-exists-p bootstrap-file)
;;       (with-current-buffer
;;           (url-retrieve-synchronously
;;            "https://raw.githubusercontent.com/radian-software/straight.el/develop/install.el"
;;            'silent 'inhibit-cookies)
;;         (goto-char (point-max))
;;         (eval-print-last-sexp)))
;;     (load bootstrap-file nil 'nomessage))
;; (setq-default straight-vc-git-default-clone-depth '(1 single-branch))
;; (setq straight-use-package-by-default t)
;; (straight-use-package 'use-package)
#+end_src
*** Straight-x
Using Straight does not mean that we can't have parallel downloads.
Use the straight-x-fetch-all to pull all the installed packages in parallel.
The use straight-merge-all to apply the pulled changed on packages.
#+begin_src emacs-lisp
;; (let ((straight-x-file (expand-file-name "straight/repos/straight.el/straight-x.el" user-emacs-directory)))
;;   (if (file-exists-p straight-x-file) (load straight-x-file)))
#+end_src
* Packages
** Keybindings
*** Undo Tree
A package which integrates into emacs keep undo history
#+begin_src emacs-lisp
(use-package undo-tree
  :config
  (setq undo-tree-history-directory-alist `(("." . ,(concat user-emacs-directory "undotree")))
        undo-tree-visualizer-diff t
        undo-tree-auto-save-history t)
  (global-undo-tree-mode))
#+end_src
*** Savehist
Package which save command history and such which are not related to files
#+begin_src emacs-lisp
(use-package savehist
  :elpaca nil
  :init
  (savehist-mode))
#+end_src
*** Evil
Reference: https://github.com/emacs-evil/evil-collection#installation
Emacs keybindings are OK but i am a vimmer
#+begin_src emacs-lisp
(use-package evil
  :init
  (setq evil-want-integration t) ;; This is optional since it's already set to t by default.
  (setq evil-want-keybinding nil)
  (setq evil-undo-system 'undo-tree)
  :config
  (evil-mode 1))
(setq evil-move-cursor-back nil
      evil-want-fine-undo t
      evil-move-beyond-eol t
      evil-respect-visual-line-mode t         ;; I don't know why this does not work and keep the visual selection after one indentation
      evil-org-retain-visual-state-on-shift t
      evil-search-module 'evil-search
      evil-vsplit-window-right t
      evil-split-window-below t)
(with-eval-after-load 'evil
  (with-eval-after-load 'elpaca-ui (evil-make-intercept-map elpaca-ui-mode-map))
  (with-eval-after-load 'elpaca-info (evil-make-intercept-map elpaca-info-mode-map)))
#+end_src
*** General
I don't want to write define-key multile times also it allows me to set keybindings in evil mode.
#+begin_src emacs-lisp
(use-package general
  :after (evil)
  :config
  (general-override-mode)
  (general-auto-unbind-keys)
  (general-evil-setup t))
#+end_src
*** Evil Collection
Evil mode for popular packages
#+begin_src emacs-lisp
(use-package evil-collection
  :after (evil)
  :config
  (evil-collection-init))
#+end_src
** Generally helpful Package
*** Tramp
#+begin_src emacs-lisp
(use-package tramp
  :elpaca nil)
#+end_src
*** PDF tools
It is useful in emacs as you can link to specific pdf pages in org mode with links like
`[[pdfview:~/path/to/pdf::<pageNo>]]`
`[[pdfview:~/test.pdf::4]]`
open 4th page in test pdf from a org mode link
#+begin_src emacs-lisp
(use-package pdf-tools
  :config
  (add-to-list 'auto-mode-alist '("\\.pdf\\'" . pdf-view-mode)))
#+end_src
*** Tempel
Tempel is a less mature tempel templatin system then yasnippet but i like it template defining syntax more as it is more native to emacs
#+begin_src emacs-lisp
(use-package tempel
  :config
  (global-tempel-abbrev-mode))
#+end_src
*** Tempel Collection
I don't have to write commonly available snippets by hand
#+begin_src emacs-lisp
(use-package tempel-collection)
#+end_src
*** ts fold
Code folding is nice
#+begin_src emacs-lisp
(use-package ts-fold
  :elpaca (ts-fold :type git :host github :repo "emacs-tree-sitter/ts-fold"))
#+end_src
*** Emms
Music Management with emacs
#+begin_src emacs-lisp
(use-package emms
  :config
  (emms-all)
  (setq emms-source-file-default-directory "~/Music/"
        emms-info-functions '(emms-info-native)
        emms-player-list '(emms-player-mpv)
        emms-history-file nil
        emms-repeat-track t
        emms-mode-line-mode t
        emms-playlist-buffer-name "*Music*"
        emms-playing-time-mode t
        emms-info-asynchronously t
        emms-source-file-directory-tree-function 'emms-source-file-directory-tree-find)
  (emms-add-directory-tree "~/Music/")
  (emms-add-directory-tree "~/Videos/Test Video"))
#+end_src
*** Helpful
Better documentation of variable,function and alike in emacs
#+begin_src emacs-lisp
(use-package helpful)
#+end_src
*** Hop
Quickly jump to any chracter in the visible buffer area `area you can see on screen`
#+begin_src emacs-lisp
(use-package pcre
  ;; :straight if you use stright.el
  :elpaca (pcre :host github :repo "syohex/emacs-pcre"
                :pre-build ("make" "all")
                :files (:default "pcre.el" "pcre-core.so")))
(use-package hop
  :elpaca (hop :host github :repo "Animeshz/hop.el"))
#+end_src
** UI
*** Unicode
#+begin_src emacs-lisp
(use-package unicode-fonts)
#+end_src
*** Fontaine
#+begin_src emacs-lisp
(use-package fontaine
  :config
  (setq fontaine-presets
        '((regular
           :default-height 100)
          (medium
           :default-weight semilight
           :default-height 140)
          (large
           :default-weight semilight
           :default-height 180
           :bold-weight extrabold)
          (t ; our shared fallback properties
           :default-family "CaskaydiaCove Nerd Font Mono"
           :default-weight normal)))
  (fontaine-set-preset 'regular))
#+end_src
*** Dashboard
Don't want to scratch buffer on startup.
#+begin_src emacs-lisp
(setq banner-icons-list (file-expand-wildcards (concat user-emacs-directory "icons/*")))
(use-package dashboard
  :after all-the-icons
  :config
  (setq dashboard-items '((recents  . 5)
                          (agenda . 5)
                          (projects . 5)))
  (setq dashboard-set-heading-icons t)
  (setq dashboard-startup-banner (random-element-of-list banner-icons-list))
  (setq dashboard-banner-logo-title "")
  (setq dashboard-image-banner-max-height 500)
  (setq dashboard-set-footer nil)
  (setq dashboard-set-file-icons t)
  (setq dashboard-set-init-info t)
  (setq initial-buffer-choice (lambda () (get-buffer-create "*dashboard*")))
  (dashboard-setup-startup-hook))
(add-hook 'server-after-make-frame-hook 'dashboard-refresh-buffer)
#+end_src
*** Which Key
Everyone forgets keybindings
#+begin_src emacs-lisp
(use-package which-key
  :init
  (which-key-mode))
#+end_src
*** Theme
**** Doom themes
#+begin_src emacs-lisp
(use-package doom-themes
  :config
  (setq doom-themes-enable-bold t
        doom-themes-enable-italic t)
  (doom-themes-visual-bell-config)

  (load-theme 'doom-dracula t)
  (add-hook 'server-after-make-frame-functions
            (lambda (frame)
              (with-selected-frame frame
                (load-theme 'doom-dracula t))))
  (custom-set-faces
   '(doom-themes-visual-bell ((t (:background "#00FFFF"))))
   '(emms-playlist-selected-face ((t (:foreground "royal blue"))))
   '(emms-playlist-track-face ((t (:foreground "#5da3e7"))))
   '(emms-playlist-selected-face ((t (:foreground "royal blue"))))
   '(emms-playlist-track-face ((t (:foreground "#5da3e7"))))
   '(org-ellipsis (( t(:foreground "#C678DD"))))))
#+end_src
**** Modus theme
High contrast theme
#+begin_src emacs-lisp
;; (use-package modus-themes
;;   :config
;;   (setq modus-themes-italic-constructs t
;;         modus-themes-bold-constructs t)
;;   (load-theme 'modus-vivendi-tinted t))
#+end_src
*** Doom modeline
Changing the default modeline to a better one ( in my opinion )
#+begin_src emacs-lisp
(use-package doom-modeline
  :elpaca (doom-modeline :host github :repo "seagle0128/doom-modeline")
  :init (doom-modeline-mode 1)
  :config
  (display-battery-mode 1)
  (setq doom-modeline-project-detection 'truncate-upto-project
        doom-modeline-enable-word-count t
        doom-modeline-buffer-encoding nil
        doom-modeline-env-version t
        doom-modeline-hud t))
#+end_src
*** Icons
**** All Icons Mode Line
Icons everywhere in emacs
#+begin_src emacs-lisp
(use-package all-the-icons)
#+end_src
**** Completions Icons
Icons in the auto completion which pop ups from the bottom ( in vertico )
#+begin_src emacs-lisp
(use-package all-the-icons-completion
  :config
  (all-the-icons-completion-mode)
  (add-hook 'marginalia-mode-hook #'all-the-icons-completion-marginalia-setup))
#+end_src
**** Corfu Icons
Icons in the word or completion menu under cursor
#+begin_src emacs-lisp
(use-package kind-icon
  :after corfu
  :custom
  (kind-icon-default-face 'corfu-default) ; to compute blended backgrounds correctly
  :config
  (add-to-list 'corfu-margin-formatters #'kind-icon-margin-formatter))
#+end_src
**** Dired Icons
Icons in file manager as well
#+begin_src emacs-lisp
(use-package all-the-icons-dired
  :config
  (add-hook 'dired-mode-hook 'all-the-icons-dired-mode))
#+end_src
** Coding
*** Evil Nerd Commentor
Smart commentor for most of the languages
#+begin_src emacs-lisp
(use-package evil-nerd-commenter)
#+end_src
*** Eglot
#+begin_src emacs-lisp
;; Best programming language so we need to include it
(use-package rustic
  :config
  (setq rustic-enable-detached-file-support t)
  (setq rustic-lsp-client 'eglot))

(use-package eldoc-box
  :config
  (setq eldoc-echo-area-use-multiline-p nil))

(use-package flycheck
  :config
  (global-flycheck-mode 1))
(use-package flycheck-eglot
  :after (flycheck eglot)
  :config
  (global-flycheck-eglot-mode 1))
(use-package eglot
  :after (eldoc-box)
  :hook ((prog-mode . eglot-ensure))
  :config
  (setq completion-category-overrides '((eglot (styles orderless))))
  (setq eldoc-idle-delay 0.0
        ;; eglot-events-buffer-size 0
        flymake-no-changes-timeout 0.5
        eglot-autoshutdown t)
  (add-hook 'eglot-managed-mode-hook #'eldoc-box-hover-mode t)
  (add-hook 'eglot-managed-mode-hook
            (lambda ()
              "Make sure Eldoc will show us all of the feedback at point."
              (setq-local eldoc-documentation-strategy
                          #'eldoc-documentation-compose)))
  (add-to-list 'eglot-ignored-server-capabilities :hoverProvider)
  (add-to-list 'eglot-server-programs '((python-mode python-ts-mode) . ("pyright-langserver" "--stdio")))
  (add-to-list 'eglot-server-programs '(svelte-mode . ("svelteserver" "--stdio")))
  (add-to-list 'eglot-server-programs `((c-mode c-ts-mode c++-mode c++-ts-mode)
                                        . ,(eglot-alternatives
                                            '("ccls" "clangd")))))
#+end_src
*** Typescript
I still have not worked out typescript support with tsx and jsx file completion but svelte works perfectly
**** Typescript Mode
#+begin_src emacs-lisp
(use-package typescript-mode
  :after tree-sitter
  :config
  ;; we choose this instead of tsx-mode so that eglot can automatically figure out language for server
  ;; see https://github.com/joaotavora/eglot/issues/624 and https://github.com/joaotavora/eglot#handling-quirky-servers
  (define-derived-mode typescriptreact-mode typescript-mode
    "TypeScript TSX")

  ;; use our derived mode for tsx files
  (add-to-list 'auto-mode-alist '("\\.tsx?\\'" . typescriptreact-mode))
  ;; by default, typescript-mode is mapped to the treesitter typescript parser
  ;; use our derived mode to map both .tsx AND .ts -> typescriptreact-mode -> treesitter tsx
  (add-to-list 'tree-sitter-major-mode-language-alist '(typescriptreact-mode . tsx)))
#+end_src
**** Web mode
#+begin_src emacs-lisp
(use-package web-mode
  :config
  (setq web-mode-markup-indent-offset 2
        web-mode-code-indent-offset 2
        web-mode-css-indent-offset 2))
#+end_src
*** Tree sitter
#+begin_src emacs-lisp
(use-package tree-sitter
  :config
  (global-tree-sitter-mode))

(use-package tree-sitter-langs
  :config
  ;; This makes every node a link to a section of code
  (setq tree-sitter-debug-jump-buttons t
        ;; and this highlights the entire sub tree in your code
        tree-sitter-debug-highlight-jump-region t))
#+end_src
*** Magit
Best git client (start with `SPC g g`)
#+begin_src emacs-lisp
(use-package magit
  :config
  (add-hook 'git-commit-post-finish-hook 'magit)
  (setq magit-display-buffer-function #'magit-display-buffer-fullframe-status-v1))
#+end_src
*** Git gutter
Little green,yellow lines on the left to show changes in git managed files
#+begin_src emacs-lisp
(use-package git-gutter-fringe
  :config
  (global-git-gutter-mode +1)
  (setq-default fringes-outside-margins t)
  ;; thin fringe bitmaps
  (define-fringe-bitmap 'git-gutter-fr:added [224]
    nil nil '(center repeated))
  (define-fringe-bitmap 'git-gutter-fr:modified [224]
    nil nil '(center repeated))
  (define-fringe-bitmap 'git-gutter-fr:deleted [128 192 224 240]
    nil nil 'bottom))
#+end_src
*** Smart compile
Allows for customization of compile command on per file name basics
#+begin_src emacs-lisp
(use-package smart-compile
  :config
  (setq smart-compile-check-build-system 'nil)
  (add-to-list 'smart-compile-alist '("\\.[Cc]+[Pp]*\\'" . "make %n && touch inputf.in && timeout 4s ./%n < inputf.in &> outputf.in "))
  (add-to-list 'smart-compile-alist  '("\\.rs$" . "touch inputf.in && cargo run -q < inputf.in &> outputf.in ")))
#+end_src
*** Evil Multi Edit
Faster editing of text and faster workflow ( go over the word you want to multi edit and press `C-d` {also works with visual mode})
#+begin_src emacs-lisp
(use-package evil-multiedit
  :config
  (evil-multiedit-default-keybinds))
#+end_src
*** Projectile
Project management . Works well with code completion modes to find the root of the project
#+begin_src emacs-lisp
(use-package projectile
  :init
  (projectile-mode +1))
#+end_src
*** Rainbow Delimiter
Don't want to match brackets with eyes just give them color.
#+begin_src emacs-lisp
(use-package rainbow-delimiters
  :hook (prog-mode . rainbow-delimiters-mode))
#+end_src
** Completion
*** Corfu
Give word completion in text file and code completions from code completion in programming files.
It has some performace issues with corfu you can use company-mode and company-box but i like corfu better as it is closer to native emacs
#+begin_src emacs-lisp
(use-package corfu
  :elpaca (corfu :host github :repo "minad/corfu" :files (:defaults "extensions/*.el"))
  :config
  ;; Setup corfu for popup like completion
  (setq corfu-cycle t  ; Allows cycling through candidates
        corfu-auto t   ; Enable auto completion
        corfu-auto-prefix 1  ; Complete with less prefix keys
        corfu-auto-delay 0.0  ; No delay for completion
        corfu-echo-documentation t ; Echo docs for current completion option
        corfu-popupinfo-delay 0.0
        corfu-quit-no-match 'separator
        corfu-quit-at-boundary 'insert)

  ;; Silence the pcomplete capf, no errors or messages!
  (advice-add 'pcomplete-completions-at-point :around #'cape-wrap-silent)

  ;; Ensure that pcomplete does not write to the buffer
  ;; and behaves as a pure `completion-at-point-function'.
  (advice-add 'pcomplete-completions-at-point :around #'cape-wrap-purify)
  (global-corfu-mode 1)
  (corfu-popupinfo-mode 1))
#+end_src
*** Cape
Giving completion to the completion system
#+begin_src emacs-lisp
(use-package cape
  :init
  (add-to-list 'completion-at-point-functions #'cape-file)
  (add-to-list 'completion-at-point-functions #'cape-dabbrev))
#+end_src
*** Embark
Performaing action in thing at point
#+begin_src emacs-lisp
(use-package embark
  :bind
  (("C-;" . embark-act)         ;; pick some comfortable binding
   ("C-h B" . embark-bindings)) ;; alternative for `describe-bindings'
  :init
  ;; Optionally replace the key help with a completing-read interface
  (setq prefix-help-command #'embark-prefix-help-command
        embark-quit-after-action nil)
  :config
  ;; Hide the mode line of the Embark live/completions buffers
  (add-to-list 'display-buffer-alist
               '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
                 nil
                 (window-parameters (mode-line-format . none)))))
(defun embark-which-key-indicator ()
  "An embark indicator that displays keymaps using which-key.
    The which-key help message will show the type and value of the
    current target followed by an ellipsis if there are further
    targets."
  (lambda (&optional keymap targets prefix)
    (if (null keymap)
        (which-key--hide-popup-ignore-command)
      (which-key--show-keymap
       (if (eq (plist-get (car targets) :type) 'embark-become)
           "Become"
         (format "Act on %s '%s'%s"
                 (plist-get (car targets) :type)
                 (embark--truncate-target (plist-get (car targets) :target))
                 (if (cdr targets) "â¦" "")))
       (if prefix
           (pcase (lookup-key keymap prefix 'accept-default)
             ((and (pred keymapp) km) km)
             (_ (key-binding prefix 'accept-default)))
         keymap)
       nil nil t (lambda (binding)
                   (not (string-suffix-p "-argument" (cdr binding))))))))

(setq embark-indicators
      '(embark-which-key-indicator
        embark-highlight-indicator
        embark-isearch-highlight-indicator))

(defun embark-hide-which-key-indicator (fn &rest args)
  "Hide the which-key indicator immediately when using the completing-read prompter."
  (which-key--hide-popup-ignore-command)
  (let ((embark-indicators
         (remq #'embark-which-key-indicator embark-indicators)))
    (apply fn args)))

(advice-add #'embark-completing-read-prompter :around #'embark-hide-which-key-indicator)
#+end_src
*** Vertico
Better completion system with a filtering with orderless
#+begin_src emacs-lisp
(use-package vertico
  :elpaca (vertico :files (:defaults "extensions/*.el"))
  :init
  (setq vertico-count 20
        vertico-resize nil
        vertico-cycle t)
  (vertico-mode))

(defun +embark-live-vertico ()
  "Shrink Vertico minibuffer when `embark-live' is active."
  (when-let (win (and (string-prefix-p "*Embark Live" (buffer-name))
                      (active-minibuffer-window)))
    (with-selected-window win
      (when (and (bound-and-true-p vertico--input)
                 (fboundp 'vertico-multiform-unobtrusive))
        (vertico-multiform-unobtrusive)))))

(add-hook 'embark-collect-mode-hook #'+embark-live-vertico)

;; A few more useful configurations...
(use-package emacs
  :elpaca nil
  :init
  ;; Add prompt indicator to `completing-read-multiple'.
  ;; We display [CRM<separator>], e.g., [CRM,] if the separator is a comma.
  (defun crm-indicator (args)
    (cons (format "[CRM%s] %s"
                  (replace-regexp-in-string
                   "\\`\\[.*?]\\*\\|\\[.*?]\\*\\'" ""
                   crm-separator)
                  (car args))
          (cdr args)))
  (advice-add #'completing-read-multiple :filter-args #'crm-indicator)

  (setq minibuffer-prompt-properties
        '(read-only t cursor-intangible t face minibuffer-prompt))
  (add-hook 'minibuffer-setup-hook #'cursor-intangible-mode)
  (setq enable-recursive-minibuffers t
        completion-cycle-threshold 3
        tab-always-indent 'complete))
#+end_src
*** Marginalia
Useful information annotation in the popup menu from the bottom
#+begin_src emacs-lisp
(use-package marginalia
  :config
  (marginalia-mode)
  (setq marginalia-align 'center
        marginalia-align-offset 20))
#+end_src
*** Orderless
Best fuzzy matching in anyway and anywhere
#+begin_src emacs-lisp
(use-package orderless
  :custom
  ;;(orderless-matching-styles '(orderless-literal orderless-regexp orderless-flex))
  (completion-styles '(orderless))
  (completion-category-overrides '((file (styles partial-completion)))))
#+end_src
*** Consult
Better command for default actions like buffer management, find and grep actions
#+begin_src emacs-lisp
(defvar consult--fd-command nil)
(defun consult--fd-builder (input)
  (unless consult--fd-command
    (setq consult--fd-command
          (if (eq 0 (call-process-shell-command "fdfind"))
              "fdfind"
            "fd")))
  (pcase-let* ((`(,arg . ,opts) (consult--command-split input))
               (`(,re . ,hl) (funcall consult--regexp-compiler
                                      arg 'extended t)))
    (when re
      (cons (append
             (list consult--fd-command
                   "--color=never" "--full-path"
                   (consult--join-regexps re 'extended))
             opts)
            hl))))

(defun consult-fd (&optional dir initial)
  (interactive "P")
  (let* ((prompt-dir (consult--directory-prompt "Fd" dir))
         (default-directory (cdr prompt-dir)))
    (find-file (consult--find (car prompt-dir) #'consult--fd-builder initial))))

(use-package consult
  :hook (completion-list-mode . consult-preview-at-point-mode)
  :init
  (setq register-preview-delay 0.5
        register-preview-function #'consult-register-format)
  (advice-add #'register-preview :override #'consult-register-window)
  (setq xref-show-xrefs-function #'consult-xref
        xref-show-definitions-function #'consult-xref)
  :config
  (consult-customize
   consult-theme :preview-key '(:debounce 0.2 any)
   consult-ripgrep consult-git-grep consult-grep
   consult-bookmark consult-recent-file consult-xref
   consult--source-bookmark consult--source-file-register
   consult--source-recent-file consult--source-project-recent-file
   ;; :preview-key (kbd "M-.")
   :preview-key '(:debounce 0.4 any))
  (defun consult--orderless-regexp-compiler (input type &rest _config)
    (setq input (orderless-pattern-compiler input))
    (cons
     (mapcar (lambda (r) (consult--convert-regexp r type)) input)
     (lambda (str) (orderless--highlight input str))))

  (setq consult--regexp-compiler #'consult--orderless-regexp-compiler)
  (setq consult-narrow-key "<")) ;; (kbd "C-+")
#+end_src
*** Embark Consult
#+begin_src emacs-lisp
(use-package embark-consult
  :hook (embark-collect-mode . consult-preview-at-point-mode))
#+end_src
** Org
*** Configuration
#+begin_src emacs-lisp
;; Automatically paste a online link with the description set to the title of the page
(use-package org-cliplink)

;; Opening links at point
(use-package link-hint)

;; Don't want to create table of content manually in org mode
(use-package toc-org)

(defadvice org-babel-execute-src-block (around load-language nil activate)
  "Load language if needed"
  (let ((language (org-element-property :language (org-element-at-point))))
    (unless (cdr (assoc (intern language) org-babel-load-languages))
      (add-to-list 'org-babel-load-languages (cons (intern language) t))
      (org-babel-do-load-languages 'org-babel-load-languages org-babel-load-languages))
    ad-do-it))

;; Life todo mangement with org mode and org agenda
(setq org-log-done 'time)
(setq org-todo-keywords
      '((sequence "TODO(t)" "PROJ(p)" "ACTIVE(a)" "REVIEW(r)" "START(s)" "NEXT(N)" "WORKING(w)" "HOLD(h)" "|" "DONE(d)" "KILL(k)")
        (sequence "|" "OKAY(o)" "YES(y)" "NO(n)")))

(defun adi/org-setup()
  (org-indent-mode +1)
  (toc-org-mode +1))

(add-hook 'org-mode-hook 'adi/org-setup)
#+end_src
*** Org Modern
Better sytling default for org mode bring more to the modern era style
#+begin_src emacs-lisp
(use-package org-modern
  :config
  (setq org-use-property-inheritance t ;;Might fix some bugs with org mode src block
        org-startup-indented t
        org-confirm-babel-evaluate nil
        org-src-preserve-indentation t
        org-export-preserve-breaks t
        org-log-into-drawer t
        org-link-file-path-type 'relative
        org-ellipsis " ï³ "                                     ;;fun symbols ï²  , ï³   , î§
        org-enforce-todo-checkbox-dependencies t
        org-enforce-todo-dependencies t
        org-auto-align-tags nil
        org-tags-column 0
        org-catch-invisible-edits 'show-and-error
        org-modern-checkbox nil
        org-modern-table nil
        org-insert-heading-respect-content t
        org-hide-emphasis-markers t
        org-pretty-entities t
        org-ellipsis "â¦")
  (global-org-modern-mode))
#+end_src
*** Org agenda
Extract todo from org files in the directory to form a logical layout
#+begin_src emacs-lisp
(setq org-agenda-files '("~/Documents/Denote/Todo/"))
(setq org-agenda-window-setup 'current-window
      org-agenda-tags-column 0
      org-agenda-start-on-weekday nil
      org-agenda-block-separator ?â
      org-agenda-time-grid
      '((daily today require-timed)
        (800 1000 1200 1400 1600 1800 2000)
        " âââââ " "âââââââââââââââ")
      org-agenda-current-time-string
      "â­  now âââââââââââââââââââââââââââââââââââââââââââââââââ"
      org-agenda-span 14
      org-agenda-start-day "-3d"
      org-agenda-inhibit-startup t)
#+end_src
*** Org Denote
Notes capturing utility
#+begin_src emacs-lisp
(defvar denote-todo-directory)
(use-package denote
  :elpaca '(denote :host github :repo "protesilaos/denote")
  :config
  (setq denote-directory "~/Documents/Denote")
  (setq denote-todo-directory (concat (denote-directory) "Todo"))
  (setq denote-known-keywords '())
  (setq denote-infer-keywords t)
  (setq denote-sort-keywords t)
  (setq denote-excluded-directories-regexp nil)
  (setq denote-excluded-keywords-regexp nil)
  (setq denote-date-prompt-use-org-read-date t)
  (setq denote-backlinks-show-context t))

(with-eval-after-load 'org-capture
  (add-to-list 'org-capture-templates
               '("n" "Notes" plain
                 (file file)
                 (function
                  (lambda ()
                    (let ((denote-directory (file-name-as-directory (concat (denote-directory) "Notes")))
                          (denote-org-capture-specifiers "%l\n%i* Notes: %?"))
                      (denote-org-capture)
                      )))
                 :no-save t
                 :immediate-finish nil
                 :kill-buffer t
                 :jump-to-captured t))
  (add-to-list 'org-capture-templates
               '("r" "Resources" plain
                 (file denote-last-path)
                 (function
                  (lambda ()
                    (let ((denote-directory (file-name-as-directory (concat (denote-directory) "Resources")))
                          (denote-org-capture-specifiers "%l\n%i\n* Resource for: %?"))
                      (denote-org-capture))))
                 :no-save t
                 :immediate-finish nil
                 :kill-buffer t
                 :jump-to-captured t))
  (add-to-list 'org-capture-templates
               '("t" "Todo" plain
                 (file denote-last-path)
                 (function
                  (lambda ()
                    (let ((denote-directory (file-name-as-directory denote-todo-directory))
                          (denote-org-capture-specifiers "%l\n%i\n* TODO %?"))
                      (denote-org-capture))))
                 :no-save t
                 :immediate-finish nil
                 :kill-buffer t
                 :jump-to-captured t)))
(add-hook 'org-capture-after-finalize-hook 'my-denote--add-todo-keyword)
#+end_src
* Package install wait
Wait till all the packages are installed with elpaca
Remove this block with you are using straight.el
#+begin_src emacs-lisp
(if (fboundp 'elpaca-wait)(elpaca-wait))
#+end_src
* Keybindings
** Leader key definer definations
#+begin_src emacs-lisp
(general-create-definer aadi/leader-keys
  :states '(normal motion visual operator emacs)
  :keymaps '(override global local)
  :prefix "SPC")
(general-create-definer aadi/leader-local-keys
  :states '(normal motion visual operator emacs)
  :keymaps '(override global local)
  :prefix "SPC m")
#+end_src
** General good defaults
#+begin_src emacs-lisp
(global-set-key (kbd "<escape>") 'keyboard-escape-quit)
(global-set-key (kbd "C-;") 'embark-act)

(general-define-key
 :keymaps 'vertico-map
 "C-j" 'vertico-next
 "C-k" 'vertico-previous)

(general-define-key
 :keymaps '(minibuffer-mode-map isearch-mode-map)
 "C-S-v" 'evil-paste-after)

(general-define-key
 :states '(normal motion operator emacs)
 :keymaps '(local global)

 "H" 'evil-beginning-of-line
 "L" 'evil-end-of-line)

(aadi/leader-keys
  "SPC" 'find-file
  "RET" 'denote-open-or-create)
(general-define-key
 :states 'motion
 "K" 'helpful-at-point
 "?" '(consult-line :which-key "filter buffer")
 "M-/" 'evilnc-comment-or-uncomment-lines)
#+end_src
** Custom Function Map
#+begin_src emacs-lisp
(general-define-key
 :states 'normal
 "," 'kitty-async-process)

(general-define-key
 :states 'insert
 "<C-backspace>" 'my/backward-kill-word)
#+end_src
** Org agenda
#+begin_src emacs-lisp
(aadi/leader-keys
  "z" 'org-agenda)
#+end_src
** Dashboard Map
#+begin_src emacs-lisp
(general-define-key
 :keymaps 'dashboard-mode-map
 :states '(normal emacs)
 "RET" 'dashboard-return)
#+end_src
** Magit Map
#+begin_src emacs-lisp
(general-define-key
 :keymaps 'transient-map
 "<escape>" 'transient-quit-one)
(aadi/leader-keys
  :states '(normal motion)
  "g" '(:ignore t :which-key "git")
  "g s" 'consult-git-grep
  "g g" 'magit)
#+end_src
** Denote Map
#+begin_src emacs-lisp
(aadi/leader-keys
  :states '(normal motion)
  "n" '(:ignore t :which-key "denote")
  "n c" 'denote-create-note-in-subdirectory
  "n n" 'denote
  "n N" 'denote-type
  "n d" 'denote-date
  "n s" 'denote-subdirectory
  "n t" 'denote-template
  "n i" 'denote-link
  "n I" 'denote-link-add-links
  "n b" 'denote-link-backlinks
  "n f f" 'denote-link-find-file
  "n f b" 'denote-link-find-backlink
  "n r" 'denote-rename-file
  "n R" 'denote-rename-file-using-front-matter)
#+end_src
** Project
#+begin_src emacs-lisp
(aadi/leader-keys
  :keymaps 'projectile-mode-map
  :states '(normal motion)
  "p" '(:keymap projectile-command-map :whick-key "projects"))
#+end_src
** Consult Map
*** Mode
#+begin_src emacs-lisp
(aadi/leader-keys
  :states '(normal motion)
  "m" '(:ignore t :which-key "mode")
  "m k" 'consult-kmacro)
#+end_src
*** Command
#+begin_src emacs-lisp
(aadi/leader-keys
  :states '(normal motion)
  "c" '(:ignore t :which-key "commands")
  "c r" '(consult-complex-command :which-key "Complex Command repeat"))
#+end_src
*** File
#+begin_src emacs-lisp
(aadi/leader-keys
  :states '(normal motion)
  "f" '(:ignore t :which-key "files")
  "f b" 'consult-bookmark
  "f r" 'consult-recent-file)
#+end_src
*** Projects
#+begin_src emacs-lisp
(general-define-key
 [remap projectile-ripgrep] 'consult-ripgrep
 [remap projectile-find-file] 'consult-find)
#+end_src
*** Goto
#+begin_src emacs-lisp
(general-define-key
 :states '(normal motion)
 "g" '(:ignore t :which-key "goto"))

(general-define-key
 :states '(normal motion)
 :prefix "g"
 "e" 'consult-compile-error
 "l" 'consult-goto-line)
#+end_src
*** Registers
#+begin_src emacs-lisp
(general-define-key
 :states '(normal motion)
 "M-C-'" 'consult-register-load
 "M-'" 'consult-register-store
 "M-\"" 'consult-register)
#+end_src
** Hop Map
#+begin_src emacs-lisp
(general-define-key
 :states '(normal motion)
 "g w" '(hop-word :which-key "goto word")
 "g c" '(hop-char :which-key "goto char"))
#+end_src
** Buffer Map
#+begin_src emacs-lisp
(aadi/leader-keys
  :states '(normal motion)
  "b" '(:ignore t :which-key "buffer")
  "b b" 'consult-buffer
  "b B" 'bookmark-bmenu-list
  "b k" 'kill-this-buffer)
#+end_src
** Org Map
#+begin_src emacs-lisp
(general-define-key
 :states '(normal motion)
 "C-c a" 'org-capture)
(general-define-key
 :keymaps 'org-mode-map
 :states 'normal
 "<RET>" '+org/dwim-at-point
 "?\t" 'org-cycle
 "C-c a" 'link-hint-copy-link-at-point
 "z i" '(org-toggle-inline-images :whick-key "inline images"))

(aadi/leader-keys org-mode-map
  "m" '(:ignore t :which-key "org localleader")
  "a" 'my-denote-move-from-todo-to-archive)
(aadi/leader-local-keys org-mode-map
  "h" '(:ignore t :which-key "heading")
  "h h" 'consult-org-heading
  "l" '(:ignore t :which-key "link")
  "l c" 'org-cliplink)
#+end_src
*** Rustic Mode
#+begin_src emacs-lisp
(aadi/leader-local-keys
  :keymaps 'rustic-mode-map
  "z" 'Competitive-coding-output-input-toggle
  "r" 'rust-reset
  "i" 'code-input-refresh
  "f" 'copy-current-file
  "c" 'smart-compile)
#+end_src
** Fold
#+begin_src emacs-lisp
(general-define-key
 :states '(normal emacs)
 "z" '(:ignore t :which-key "fold")
 "z z" 'ts-fold-toggle
 "z r" 'ts-fold-open-recursively
 "z c" 'ts-fold-close-all
 "z o" 'ts-fold-open-all)
#+end_src
** Helpful
#+begin_src emacs-lisp
(general-define-key
 :prefix "C-h"
 "f" 'helpful-callable
 "v" 'helpful-variable
 "k" 'helpful-key
 "F" 'helpful-function
 "C" 'helpful-command)
#+end_src
** Tempel
#+begin_src emacs-lisp
(general-define-key
 :states 'insert
 "C-s" 'tempel-complete)
(general-define-key
 :states '(insert normal)
 :keymaps 'tempel-map
 "S-TAB" 'tempel-previous
 "TAB" 'tempel-next)
#+end_src
** Eglot
#+begin_src emacs-lisp
(aadi/leader-keys eglot-mode-map
  "m" '(:ignore t :which-key "eglot localleader"))
(aadi/leader-local-keys eglot-mode-map
  "a" 'eglot-format)
#+end_src
